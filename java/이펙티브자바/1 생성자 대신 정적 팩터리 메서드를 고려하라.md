## 생성자 대신 정적 팩터리 메서드를 고려하라
### 정적 팩터리 메서드
클래스의 인스턴스를 반환하는 단순한 정적 메서드
```java
public class Webtoon {
    private String name;
    private String author;
    private String publisher;

    private Webtoon() {}

    // 정적 팩터리 메서드    
    public static Webtoon create() {
        return new Webtoon();
    }
}
```

### 정적 팩터리 메서드의 장점
**1. 이름을 가질 수 있다.**  
생성자에 넘기는 매개변수와 생성자 자체만으로는 반환될 객체의 특성을 제대로 설명하지 못한다.  
또한, 한 클래스에 시그니처가 같은 생성자가 여러 개 필요하면, 생성자를 정적 팩터리 메서드로 바꾸고 각각의 차이가 잘 드러나는 이름을 지어주면 된다.  
```java
public class Webtoon {
    private String name;
    private String author;

    private Webtoon() {}
    
    public static Webtoon createWebtoonFromName(String name) {
        Webtoon webtoon = new Webtoon();
        Webtoon.name = name;
        return webtoon;
    }
    
    public static Webtoon createWebtoonFromAuthor(String author) {
        Webtoon webtoon = new Webtoon();
        Webtoon.author = author;
        return webtoon;
    }
}
```
<br />

**2. 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.**  
이 덕분에 불변클래스는 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하는 식으로 불필요한 객체 생성을 피할 수 있다.  
```java
public final class Boolean implements java.io.Serializable, Comparable<Boolean> {
    public static final Boolean TRUE = new Boolean(true);
    public static final Boolean FALSE = new Boolean(false);

    public static Boolean valueOf(boolean b) {
        return (b ? TRUE : FALSE);
    }
}
```
TRUE, FALSE 라는 인스턴스를 미리 생성하여 재활용하기 때문에 불필요한 객체 생성을 하지 않는다.  
<br />

**3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.**  
리턴 타입을 인터페이스로 지정하고, 실제 인터페이스의 구현체를 리턴하므로써 구현체를 노출시키지 않고 객체를 생성할 수 있다.  
```java
public class Collections {
    private Collections() {
    }

    /**
     * List 의 타입에 따라 다른 구현체 응답
     * @return : List 
     */
    public static <T> List<T> unmodifiableList(List<? extends T> list) {
        return (list instanceof RandomAccess ?
            new UnmodifiableRandomAccessList<>(list) :
            new UnmodifiableList<>(list));
    }

    // UnmodifiableList 구현
    static class UnmodifiableList<E> extends UnmodifiableCollection<E> implements List<E> {
        // ...
    }
    
    // UnmodifiableRandomAccessList 구현체
    static class UnmodifiableRandomAccessList<E> extends UnmodifiableList<E> implements RandomAccess {
        // ...
    }
}
```
구현 클래스를 공개하지 않고도 그 객체를 반환할 수 있어 API를 작게 유지할 수 있다.  
이는 인터페이스를 정적 팩터리 메서드의 반환 타입으로 사용하는 인터페이스 기반 프레임워크를 만드는 핵심 기술이다.  
<br />

**4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.**  
반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없다. (위의 3번 예제와 비슷한 내용)  
예를 들어, ```EnumSet```은 원소의 개수에 따라 다른 객체를 리턴한다.  
클라이언트는 이 두 클래스의 존재를 알지 못하고, 만약 원소가 적을 때 ```RegularEnumSet```을 사용하는데 이점이 없다면 다음 릴리즈때 제거해도 아무 문제가 없다.  
```java
public abstract class EnumSet<E extends Enum<E>> extends AbstractSet<E> implements Cloneable, java.io.Serializable {
    public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType) {
        Enum<?>[] universe = getUniverse(elementType);
        if (universe == null)
            throw new ClassCastException(elementType + " not an enum");

        if (universe.length <= 64)
            return new RegularEnumSet<>(elementType, universe);
        else
            return new JumboEnumSet<>(elementType, universe);
    }
}
```  
<br />

**5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.**
서비스 제공자 프레임워크 : 서비스는 클라이언트(사용자)가 구현해야할 인터페이스를 정의하고, 클라이언트(사용자)가 자신의 환경에 맞는 구현체를 직접 정의하여 제공하면 서비스에서는 해당 구현체를 받아서 사용하는 형태로 동작하는 것    
구성요소  
* 서비스 인터페이스 : 구현체의 동작을 정의 즉, 사용자가 구현해야할 인터페이스를 정의
* 서비스 등록 API : 제공자가 구현체를 등록할 때 사용하는 제공자 등록 API