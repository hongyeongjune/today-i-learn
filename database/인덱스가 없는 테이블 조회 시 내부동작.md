### 인덱스가 없는 테이블 조회 시 내부동작

#### clustered index
* MySQL에서 클러스터링 인덱스는 InnoDB 스토리지 엔진에서만 지원한다. (나머지는 지원x)
* 클러스터링 인덱스는 Primary Key에 대해서만 적용되는 내용이다.
* 클러스터링 인덱스 구조를 보면 일반 B-Tree의 구조와 비슷하다. 하지만 세컨더리 인덱스를 위한 B-Tree의 리프 노드와는 달리 클러스터링 인덱스의 리프 노드에는 레코드의 모든 컬럼이 저장되어 있다.
* 따로 인덱스 설정을 하지 않아도 기본적으로 Primary Key를 기준으로 클러스터링 인덱스가 생성된다.

#### Optimizer
* MySQL의 쿼리 실행 절차 
  1. 사용자로부터 요청된 SQL 문장을 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리한다.
     * SQL 문장이 문법적으로 잘못되었다면 이 단계에서 검증
  2. SQL의 파싱 정보를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
     * 이 단계는 **최적화 및 실행 계획 수립** 단계이다.
     * 불필요한 조건 제거 및 복잡한 연산의 단순화
     * 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
     * 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
     * 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
  3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.
* 현재 대부분의 DBMS는 비용 기반 최적화(Cost-based optimizer, CBO) 방법을 사용하고 있다.
  * 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출한다. 이렇게 산출된 실행 방법별로 비용이 최소로 소요되는 처리 방식을 선택해 쿼리를 실행한다.
* Full Table Scan
  * 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미한다.
  * 조건
    * 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우(일반적으로 테이블이 페이지 1개로 구성된 경우)
    * ```where``` 절이나 ```on``` 절에 인덱스를 사용할 수 있는 적절한 조건이 없는 경우
    * 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
  * 테이블을 처음부터 끝까지 읽는 작업은 상당히 많은 디스크 읽기가 필요하다. MySQL에는 풀 테이블 스캔을 실행할 때 한꺼번에 몇 개씩 페이지를 읽어올지 설정하는 시스테 변수는 없다. 그래서 많은 사람들이 디스크로부터 페이지를 하나씩 읽어 오는 것으로 생각하지만, 이것은 잘못된 생각이다. (MyISAM 스토리지 엔진은 맞지만 InnoDB 스토리지 엔진은 틀린 말이다.)
  * InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드(Read ahead) 작업이 자동으로 시작된다.
    * 리드 어헤드란 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB 버퍼 풀에 가자다 두는 것을 의미한다.
* 예시
  * ```mysql> select count(*) from employees```
    * 이 쿼리는 아무런 조건 없이 employees 테이블의 레코드 건수를 조회하고 있으므로 풀 테이블 스캔을 할 것으로 보이지만, 실제로는 풀 인덱스 스캔을 할 가능성이 높다.
    * MySQL 서버는 단순한 레코드의 건수만 필요로 하는 쿼리라면 용량이 작은 인덱스를 선택하는 것이 디스크 읽기 횟수를 줄일 수 있기 때문이다.
  * ```mysql> select * from employees```
    * 이 쿼리는 레코드에만 있는 컬럼이 필요한 쿼리이기 때문에 풀 인덱스 스캔을 활용하지 못하고 풀 테이블 스캔을 할 확률이 높다.

#### 인덱스가 없는 테이블 조회 시 내부동작
* 인덱스를 따로 설정하지 않아도 Primary Key를 기준으로 클러스터링 인덱스가 자동으로 설정된다.
* 따라서 모든 레코드를 조회할 때 where 절에 PK를 걸면 인덱스 스캔을 진행하고 where 절에 인덱스가 안 걸린 값을 넣어주면 풀 테이블 스캔을 진행한다.